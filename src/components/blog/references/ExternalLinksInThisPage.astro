---
import type { Block, Post, ReferencesInPage } from "@/lib/interfaces";
import createMetascraper from "metascraper";
import metascraperDescription from "metascraper-description";
import metascraperImage from "metascraper-image";
import metascraperTitle from "metascraper-title";
import NBlocksPopover from "./NBlocksPopover.astro";
import { buildURLToHTMLMap, getReferenceLink } from "@/lib/blog-helpers";
import { REFERENCES } from "@/constants";
import Icon from "@/components/Icon";

interface Props {
	post: Post;
	filteredReferencesInPage: ReferencesInPage[];
}
const { post, filteredReferencesInPage } = Astro.props;
const groupedReferences: { [key: string]: Block[] } = filteredReferencesInPage.reduce(
	(acc: { [key: string]: Block[] }, ref) => {
		// Group by direct_nonmedia_link and collect Block objects
		if (ref.direct_nonmedia_link && !ref.direct_nonmedia_link.includes("tiktok.com")) {
			const key = ref.direct_nonmedia_link;
			acc[key] = acc[key] || [];
			acc[key].push(ref.block);
		}

		// Group by each Href in external_hrefs and collect Block objects
		ref.external_hrefs.forEach((richText) => {
			if (richText.Href && !richText.Href.includes("tiktok.com")) {
				const key = richText.Href;
				acc[key] = acc[key] || [];
				acc[key].push(ref.block);
			}
		});

		return acc;
	},
	{} as { [key: string]: Block[] },
);

const blockIdLinks: Record<string, string | null> = {};
const urlList: URL[] = [];
const hrefMetaData: Record<string, { title?: string; description?: string; image?: string }> = {};

if (groupedReferences) {
	for (const hrefLink of Object.keys(groupedReferences)) {
		let url: URL;
		try {
			url = new URL(hrefLink);
			urlList.push(url);
			const blocks = groupedReferences[hrefLink];
			if (blocks) {
				for (const block of blocks) {
					const result = await getReferenceLink(post.PageId, undefined, block, true);
					blockIdLinks[block.Id] = result[0];
				}
			}
		} catch (err) {
			console.log(err);
			delete groupedReferences[hrefLink];
			continue;
		}
	}
}

const urlMap = await buildURLToHTMLMap(urlList);

const metascraper = createMetascraper([
	metascraperTitle(),
	metascraperImage(),
	metascraperDescription(),
]);

if (groupedReferences && urlMap) {
	for (const hrefLink of Object.keys(groupedReferences)) {
		let url: URL;
		try {
			url = new URL(hrefLink);
			const html = urlMap[hrefLink];
			if (html) {
				const metadata = await metascraper({ html, url: url.toString() });
				if (!metadata || !metadata.title) {
					delete groupedReferences[hrefLink];
					continue;
				} else {
					hrefMetaData[hrefLink] = metadata as { title?: string; description?: string; image?: string };
				}
			} else {
				delete groupedReferences[hrefLink];
			}
		} catch (err) {
			console.log(err);
			delete groupedReferences[hrefLink];
			continue;
		}
	}
}
---

{
	groupedReferences && Object.keys(groupedReferences).length > 0 && urlMap && (
		<>
			<details class="toggle" id="external-links">
				<summary class="flex max-w-full cursor-pointer list-outside list-none gap-2">
					<div class="-ml-7">
						<Icon
							name={"toggle-triangle"}
							class="rotate-svg h-6 w-6 flex-shrink-0 transition-all duration-300"
							aria-label="Toggle open/close"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="2"
						/>
					</div>
					<div>
						<span class="font-semibold">External Links On This Page</span>
					</div>
				</summary>
				<div class="pl-2">
					{Object.entries(groupedReferences).map(([hrefLink, blocks]) => {
						const metaData = hrefMetaData[hrefLink];
						const title = metaData?.title || hrefLink;
						return (
							<div>
								<div class="inline-block">
									<a
										href={hrefLink}
										class="text-link no-underline hover:underline hover:decoration-accent-2 hover:underline-offset-4"
									>
										{title.length > 35 ? `${title.slice(0, 35)}â€¦` : title}
									</a>
									{" at "}
									{REFERENCES && REFERENCES["popovers"] ? (
										<>
											{blocks.map((block, index) => (
												<NBlocksPopover
													block={block}
													linkedTo={blockIdLinks[block.Id] || "#"}
													popoverSpanText={`[${index + 1}]`}
													font={"font-mono"}
												/>
											))}
										</>
									) : (
										<>
											{blocks.map((block, index) => (
												<a href={blockIdLinks[block.Id] || "#"} class="font-mono text-link">
													{`[${index + 1}]`}
												</a>
											))}
										</>
									)}
								</div>
							</div>
						);
					})}
				</div>
			</details>
			<br />
		</>
	)
}

<style>
	.toggle > summary > a {
		display: inline;
	}
	details[open] > summary > div > .flex-shrink-0.rotate-svg {
		transform: rotate(90deg);
	}
	summary::-webkit-details-marker {
		display: none;
	}
</style>
